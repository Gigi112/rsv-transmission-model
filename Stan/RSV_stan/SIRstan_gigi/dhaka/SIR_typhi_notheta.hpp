// Code generated by Stan version 2.9

#include <stan/model/model_header.hpp>

namespace SIR_typhi_notheta_model_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;
template <typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__>
inline
std::vector<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__>::type>::type>
make_x_r(const int& agegroups,
             const T1__& population,
             const T2__& mub,
             const T3__& alpha,
             const T4__& omega,
             const T5__& delta,
             const std::vector<T6__>& mu,
             const std::vector<T7__>& theta,
             const std::vector<T8__>& u, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            vector<fun_scalar_t__> x_r((agegroups * 8));
            stan::math::initialize(x_r, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 13;
            stan::math::assign(get_base1_lhs(x_r,1,"x_r",1), population);
            current_statement_begin__ = 14;
            stan::math::assign(get_base1_lhs(x_r,(1 + agegroups),"x_r",1), mub);
            current_statement_begin__ = 15;
            for (int j = 2; j <= agegroups; ++j) {
                current_statement_begin__ = 16;
                stan::math::assign(get_base1_lhs(x_r,j,"x_r",1), 0);
                current_statement_begin__ = 17;
                stan::math::assign(get_base1_lhs(x_r,(j + agegroups),"x_r",1), 0);
            }
            current_statement_begin__ = 19;
            for (int i = 1; i <= agegroups; ++i) {
                current_statement_begin__ = 20;
                stan::math::assign(get_base1_lhs(x_r,(i + (agegroups * 2)),"x_r",1), alpha);
                current_statement_begin__ = 21;
                stan::math::assign(get_base1_lhs(x_r,(i + (agegroups * 3)),"x_r",1), omega);
                current_statement_begin__ = 22;
                stan::math::assign(get_base1_lhs(x_r,(i + (agegroups * 4)),"x_r",1), delta);
            }
            current_statement_begin__ = 25;
            stan::model::assign(x_r, 
                        stan::model::cons_list(stan::model::index_min_max((1 + (agegroups * 5)), (agegroups * 6)), stan::model::nil_index_list()), 
                        mu, 
                        "assigning variable x_r");
            current_statement_begin__ = 26;
            stan::model::assign(x_r, 
                        stan::model::cons_list(stan::model::index_min_max((1 + (agegroups * 6)), (agegroups * 7)), stan::model::nil_index_list()), 
                        theta, 
                        "assigning variable x_r");
            current_statement_begin__ = 27;
            stan::model::assign(x_r, 
                        stan::model::cons_list(stan::model::index_min_max((1 + (agegroups * 7)), (agegroups * 8)), stan::model::nil_index_list()), 
                        u, 
                        "assigning variable x_r");
            current_statement_begin__ = 28;
            return stan::math::promote_scalar<fun_return_scalar_t__>(x_r);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct make_x_r_functor__ {
    template <typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__>
    inline
    std::vector<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__>::type>::type>
    operator()(const int& agegroups,
             const T1__& population,
             const T2__& mub,
             const T3__& alpha,
             const T4__& omega,
             const T5__& delta,
             const std::vector<T6__>& mu,
             const std::vector<T7__>& theta,
             const std::vector<T8__>& u, std::ostream* pstream__) const {
        return make_x_r(agegroups, population, mub, alpha, omega, delta, mu, theta, u, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
inline
std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type>
make_params(const T0__& beta,
                const T1__& logm1,
                const T2__& logm2,
                const T3__& r,
                const int& agegroups, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            vector<fun_scalar_t__> params((agegroups + 1));
            stan::math::initialize(params, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 36;
            stan::math::assign(get_base1_lhs(params,1,"params",1), (exp(-(logm1)) * beta));
            current_statement_begin__ = 37;
            stan::math::assign(get_base1_lhs(params,2,"params",1), ((1 - exp(-(logm2))) * beta));
            current_statement_begin__ = 38;
            for (int i = 3; i <= agegroups; ++i) {
                current_statement_begin__ = 39;
                stan::math::assign(get_base1_lhs(params,i,"params",1), beta);
            }
            current_statement_begin__ = 40;
            stan::math::assign(get_base1_lhs(params,(agegroups + 1),"params",1), r);
            current_statement_begin__ = 41;
            return stan::math::promote_scalar<fun_return_scalar_t__>(params);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct make_params_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
    inline
    std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type>
    operator()(const T0__& beta,
                const T1__& logm1,
                const T2__& logm2,
                const T3__& r,
                const int& agegroups, std::ostream* pstream__) const {
        return make_params(beta, logm1, logm2, r, agegroups, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
inline
std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type>
sir(const T0__& t,
        const std::vector<T1__>& y,
        const std::vector<T2__>& theta,
        const std::vector<T3__>& x_r,
        const std::vector<int>& x_i, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            vector<fun_scalar_t__> dydt((8 * get_base1(x_i,1,"x_i",1)));
            stan::math::initialize(dydt, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 49;
            for (int j = 1; j <= 1; ++j) {
                current_statement_begin__ = 50;
                stan::math::assign(get_base1_lhs(dydt,j,"dydt",1), ((get_base1(x_r,(j + get_base1(x_i,1,"x_i",1)),"x_r",1) - (get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 7)),"y",1) * get_base1(y,j,"y",1))) - ((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) + get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 5)),"x_r",1)) * get_base1(y,j,"y",1))));
                current_statement_begin__ = 52;
                stan::math::assign(get_base1_lhs(dydt,(j + get_base1(x_i,1,"x_i",1)),"dydt",1), (((get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 7)),"y",1) * get_base1(y,j,"y",1)) - (get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 4)),"x_r",1) * get_base1(y,(j + get_base1(x_i,1,"x_i",1)),"y",1))) - ((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) + get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 5)),"x_r",1)) * get_base1(y,(j + get_base1(x_i,1,"x_i",1)),"y",1))));
                current_statement_begin__ = 54;
                stan::math::assign(get_base1_lhs(dydt,(j + (get_base1(x_i,1,"x_i",1) * 2)),"dydt",1), (((((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 4)),"x_r",1) * ((1 - get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 2)),"x_r",1)) - get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 6)),"x_r",1))) * get_base1(y,(j + get_base1(x_i,1,"x_i",1)),"y",1)) + ((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 4)),"x_r",1) * (1 - (get_base1(x_i,2,"x_i",1) * get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 6)),"x_r",1)))) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 4)),"y",1))) - (get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 3)),"x_r",1) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 2)),"y",1))) - ((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) + get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 5)),"x_r",1)) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 2)),"y",1))));
                current_statement_begin__ = 55;
                stan::math::assign(get_base1_lhs(dydt,(j + (get_base1(x_i,1,"x_i",1) * 3)),"dydt",1), (((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 3)),"x_r",1) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 2)),"y",1)) - (get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 7)),"y",1) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 3)),"y",1))) - ((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) + get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 5)),"x_r",1)) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 3)),"y",1))));
                current_statement_begin__ = 56;
                stan::math::assign(get_base1_lhs(dydt,(j + (get_base1(x_i,1,"x_i",1) * 4)),"dydt",1), (((get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 7)),"y",1) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 3)),"y",1)) - (get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 4)),"x_r",1) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 4)),"y",1))) - ((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) + get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 5)),"x_r",1)) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 4)),"y",1))));
                current_statement_begin__ = 57;
                stan::math::assign(get_base1_lhs(dydt,(j + (get_base1(x_i,1,"x_i",1) * 5)),"dydt",1), (((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 4)),"x_r",1) * get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 6)),"x_r",1)) * (get_base1(y,(j + get_base1(x_i,1,"x_i",1)),"y",1) + (get_base1(x_i,2,"x_i",1) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 4)),"y",1)))) - ((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) + get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 5)),"x_r",1)) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 5)),"y",1))));
                current_statement_begin__ = 58;
                stan::math::assign(get_base1_lhs(dydt,(j + (get_base1(x_i,1,"x_i",1) * 6)),"dydt",1), (get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 7)),"y",1) * get_base1(y,j,"y",1)));
                current_statement_begin__ = 59;
                stan::math::assign(get_base1_lhs(dydt,(j + (get_base1(x_i,1,"x_i",1) * 7)),"dydt",1), (((get_base1(theta,j,"theta",1) * ((sum(stan::model::rvalue(y, stan::model::cons_list(stan::model::index_min_max((get_base1(x_i,1,"x_i",1) + 1), (2 * get_base1(x_i,1,"x_i",1))), stan::model::nil_index_list()), "y")) + (((get_base1(theta,(get_base1(x_i,1,"x_i",1) + 1),"theta",1) * get_base1(x_i,3,"x_i",1)) + (1 - get_base1(x_i,3,"x_i",1))) * sum(stan::model::rvalue(y, stan::model::cons_list(stan::model::index_min_max(((4 * get_base1(x_i,1,"x_i",1)) + 1), (5 * get_base1(x_i,1,"x_i",1))), stan::model::nil_index_list()), "y")))) + (get_base1(theta,(get_base1(x_i,1,"x_i",1) + 1),"theta",1) * sum(stan::model::rvalue(y, stan::model::cons_list(stan::model::index_min_max(((5 * get_base1(x_i,1,"x_i",1)) + 1), (6 * get_base1(x_i,1,"x_i",1))), stan::model::nil_index_list()), "y"))))) / get_base1(x_r,1,"x_r",1)) - get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 7)),"y",1)));
            }
            current_statement_begin__ = 61;
            for (int j = 2; j <= get_base1(x_i,1,"x_i",1); ++j) {
                current_statement_begin__ = 62;
                stan::math::assign(get_base1_lhs(dydt,j,"dydt",1), (((-(get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 7)),"y",1)) * get_base1(y,j,"y",1)) - ((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) + get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 5)),"x_r",1)) * get_base1(y,j,"y",1))) + (get_base1(x_r,((j - 1) + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) * get_base1(y,(j - 1),"y",1))));
                current_statement_begin__ = 63;
                stan::math::assign(get_base1_lhs(dydt,(j + get_base1(x_i,1,"x_i",1)),"dydt",1), ((((get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 7)),"y",1) * get_base1(y,j,"y",1)) - (get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 4)),"x_r",1) * get_base1(y,(j + get_base1(x_i,1,"x_i",1)),"y",1))) - ((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) + get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 5)),"x_r",1)) * get_base1(y,(j + get_base1(x_i,1,"x_i",1)),"y",1))) + (get_base1(x_r,((j - 1) + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) * get_base1(y,((j - 1) + get_base1(x_i,1,"x_i",1)),"y",1))));
                current_statement_begin__ = 64;
                stan::math::assign(get_base1_lhs(dydt,(j + (get_base1(x_i,1,"x_i",1) * 2)),"dydt",1), ((((((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 4)),"x_r",1) * ((1 - get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 2)),"x_r",1)) - get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 6)),"x_r",1))) * get_base1(y,(j + get_base1(x_i,1,"x_i",1)),"y",1)) + ((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 4)),"x_r",1) * (1 - (get_base1(x_i,2,"x_i",1) * get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 6)),"x_r",1)))) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 4)),"y",1))) - (get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 3)),"x_r",1) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 2)),"y",1))) - ((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) + get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 5)),"x_r",1)) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 2)),"y",1))) + (get_base1(x_r,((j - 1) + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) * get_base1(y,((j - 1) + (get_base1(x_i,1,"x_i",1) * 2)),"y",1))));
                current_statement_begin__ = 65;
                stan::math::assign(get_base1_lhs(dydt,(j + (get_base1(x_i,1,"x_i",1) * 3)),"dydt",1), ((((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 3)),"x_r",1) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 2)),"y",1)) - (get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 7)),"y",1) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 3)),"y",1))) - ((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) + get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 5)),"x_r",1)) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 3)),"y",1))) + (get_base1(x_r,((j - 1) + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) * get_base1(y,((j - 1) + (get_base1(x_i,1,"x_i",1) * 3)),"y",1))));
                current_statement_begin__ = 66;
                stan::math::assign(get_base1_lhs(dydt,(j + (get_base1(x_i,1,"x_i",1) * 4)),"dydt",1), ((((get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 7)),"y",1) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 3)),"y",1)) - (get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 4)),"x_r",1) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 4)),"y",1))) - ((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) + get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 5)),"x_r",1)) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 4)),"y",1))) + (get_base1(x_r,((j - 1) + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) * get_base1(y,((j - 1) + (get_base1(x_i,1,"x_i",1) * 4)),"y",1))));
                current_statement_begin__ = 67;
                stan::math::assign(get_base1_lhs(dydt,(j + (get_base1(x_i,1,"x_i",1) * 5)),"dydt",1), ((((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 4)),"x_r",1) * get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 6)),"x_r",1)) * (get_base1(y,(j + get_base1(x_i,1,"x_i",1)),"y",1) + (get_base1(x_i,2,"x_i",1) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 4)),"y",1)))) - ((get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) + get_base1(x_r,(j + (get_base1(x_i,1,"x_i",1) * 5)),"x_r",1)) * get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 5)),"y",1))) + (get_base1(x_r,((j - 1) + (get_base1(x_i,1,"x_i",1) * 7)),"x_r",1) * get_base1(y,((j - 1) + (get_base1(x_i,1,"x_i",1) * 5)),"y",1))));
                current_statement_begin__ = 68;
                stan::math::assign(get_base1_lhs(dydt,(j + (get_base1(x_i,1,"x_i",1) * 6)),"dydt",1), (get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 7)),"y",1) * get_base1(y,j,"y",1)));
                current_statement_begin__ = 69;
                stan::math::assign(get_base1_lhs(dydt,(j + (get_base1(x_i,1,"x_i",1) * 7)),"dydt",1), (((get_base1(theta,j,"theta",1) * ((sum(stan::model::rvalue(y, stan::model::cons_list(stan::model::index_min_max((get_base1(x_i,1,"x_i",1) + 1), (2 * get_base1(x_i,1,"x_i",1))), stan::model::nil_index_list()), "y")) + (((get_base1(theta,(get_base1(x_i,1,"x_i",1) + 1),"theta",1) * get_base1(x_i,3,"x_i",1)) + (1 - get_base1(x_i,3,"x_i",1))) * sum(stan::model::rvalue(y, stan::model::cons_list(stan::model::index_min_max(((4 * get_base1(x_i,1,"x_i",1)) + 1), (5 * get_base1(x_i,1,"x_i",1))), stan::model::nil_index_list()), "y")))) + (get_base1(theta,(get_base1(x_i,1,"x_i",1) + 1),"theta",1) * sum(stan::model::rvalue(y, stan::model::cons_list(stan::model::index_min_max(((5 * get_base1(x_i,1,"x_i",1)) + 1), (6 * get_base1(x_i,1,"x_i",1))), stan::model::nil_index_list()), "y"))))) / get_base1(x_r,1,"x_r",1)) - get_base1(y,(j + (get_base1(x_i,1,"x_i",1) * 7)),"y",1)));
            }
            current_statement_begin__ = 71;
            return stan::math::promote_scalar<fun_return_scalar_t__>(dydt);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct sir_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
    inline
    std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type>
    operator()(const T0__& t,
        const std::vector<T1__>& y,
        const std::vector<T2__>& theta,
        const std::vector<T3__>& x_r,
        const std::vector<int>& x_i, std::ostream* pstream__) const {
        return sir(t, y, theta, x_r, x_i, pstream__);
    }
};

class SIR_typhi_notheta_model : public prob_grad {
private:
    int ts;
    vector<double> tspan;
    int agegroups;
    int thetaindicator;
    int rindicator;
    vector<int> cases;
    vector<int> casesdhaka2;
    double alpha;
    double omega;
    double delta;
    double population;
    double mub;
    int dhaka;
    vector<double> y0;
    vector<double> mu;
    vector<double> u;
    vector<double> theta;
    vector<double> participation;
    vector<double> vol;
    double t0;
    vector<double> x_r;
    vector<int> x_i;
public:
    SIR_typhi_notheta_model(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        current_statement_begin__ = -1;

        static const char* function__ = "SIR_typhi_notheta_model_namespace::SIR_typhi_notheta_model";
        (void) function__; // dummy call to supress warning
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        context__.validate_dims("data initialization", "ts", "int", context__.to_vec());
        ts = int(0);
        vals_i__ = context__.vals_i("ts");
        pos__ = 0;
        ts = vals_i__[pos__++];
        context__.validate_dims("data initialization", "tspan", "double", context__.to_vec(ts));
        validate_non_negative_index("tspan", "ts", ts);
        tspan = std::vector<double>(ts,double(0));
        vals_r__ = context__.vals_r("tspan");
        pos__ = 0;
        size_t tspan_limit_0__ = ts;
        for (size_t i_0__ = 0; i_0__ < tspan_limit_0__; ++i_0__) {
            tspan[i_0__] = vals_r__[pos__++];
        }
        context__.validate_dims("data initialization", "agegroups", "int", context__.to_vec());
        agegroups = int(0);
        vals_i__ = context__.vals_i("agegroups");
        pos__ = 0;
        agegroups = vals_i__[pos__++];
        context__.validate_dims("data initialization", "thetaindicator", "int", context__.to_vec());
        thetaindicator = int(0);
        vals_i__ = context__.vals_i("thetaindicator");
        pos__ = 0;
        thetaindicator = vals_i__[pos__++];
        context__.validate_dims("data initialization", "rindicator", "int", context__.to_vec());
        rindicator = int(0);
        vals_i__ = context__.vals_i("rindicator");
        pos__ = 0;
        rindicator = vals_i__[pos__++];
        context__.validate_dims("data initialization", "cases", "int", context__.to_vec(agegroups));
        validate_non_negative_index("cases", "agegroups", agegroups);
        cases = std::vector<int>(agegroups,int(0));
        vals_i__ = context__.vals_i("cases");
        pos__ = 0;
        size_t cases_limit_0__ = agegroups;
        for (size_t i_0__ = 0; i_0__ < cases_limit_0__; ++i_0__) {
            cases[i_0__] = vals_i__[pos__++];
        }
        context__.validate_dims("data initialization", "casesdhaka2", "int", context__.to_vec(2));
        validate_non_negative_index("casesdhaka2", "2", 2);
        casesdhaka2 = std::vector<int>(2,int(0));
        vals_i__ = context__.vals_i("casesdhaka2");
        pos__ = 0;
        size_t casesdhaka2_limit_0__ = 2;
        for (size_t i_0__ = 0; i_0__ < casesdhaka2_limit_0__; ++i_0__) {
            casesdhaka2[i_0__] = vals_i__[pos__++];
        }
        context__.validate_dims("data initialization", "alpha", "double", context__.to_vec());
        alpha = double(0);
        vals_r__ = context__.vals_r("alpha");
        pos__ = 0;
        alpha = vals_r__[pos__++];
        context__.validate_dims("data initialization", "omega", "double", context__.to_vec());
        omega = double(0);
        vals_r__ = context__.vals_r("omega");
        pos__ = 0;
        omega = vals_r__[pos__++];
        context__.validate_dims("data initialization", "delta", "double", context__.to_vec());
        delta = double(0);
        vals_r__ = context__.vals_r("delta");
        pos__ = 0;
        delta = vals_r__[pos__++];
        context__.validate_dims("data initialization", "population", "double", context__.to_vec());
        population = double(0);
        vals_r__ = context__.vals_r("population");
        pos__ = 0;
        population = vals_r__[pos__++];
        context__.validate_dims("data initialization", "mub", "double", context__.to_vec());
        mub = double(0);
        vals_r__ = context__.vals_r("mub");
        pos__ = 0;
        mub = vals_r__[pos__++];
        context__.validate_dims("data initialization", "dhaka", "int", context__.to_vec());
        dhaka = int(0);
        vals_i__ = context__.vals_i("dhaka");
        pos__ = 0;
        dhaka = vals_i__[pos__++];
        context__.validate_dims("data initialization", "y0", "double", context__.to_vec((agegroups * 8)));
        validate_non_negative_index("y0", "(agegroups * 8)", (agegroups * 8));
        y0 = std::vector<double>((agegroups * 8),double(0));
        vals_r__ = context__.vals_r("y0");
        pos__ = 0;
        size_t y0_limit_0__ = (agegroups * 8);
        for (size_t i_0__ = 0; i_0__ < y0_limit_0__; ++i_0__) {
            y0[i_0__] = vals_r__[pos__++];
        }
        context__.validate_dims("data initialization", "mu", "double", context__.to_vec(agegroups));
        validate_non_negative_index("mu", "agegroups", agegroups);
        mu = std::vector<double>(agegroups,double(0));
        vals_r__ = context__.vals_r("mu");
        pos__ = 0;
        size_t mu_limit_0__ = agegroups;
        for (size_t i_0__ = 0; i_0__ < mu_limit_0__; ++i_0__) {
            mu[i_0__] = vals_r__[pos__++];
        }
        context__.validate_dims("data initialization", "u", "double", context__.to_vec(agegroups));
        validate_non_negative_index("u", "agegroups", agegroups);
        u = std::vector<double>(agegroups,double(0));
        vals_r__ = context__.vals_r("u");
        pos__ = 0;
        size_t u_limit_0__ = agegroups;
        for (size_t i_0__ = 0; i_0__ < u_limit_0__; ++i_0__) {
            u[i_0__] = vals_r__[pos__++];
        }
        context__.validate_dims("data initialization", "theta", "double", context__.to_vec(agegroups));
        validate_non_negative_index("theta", "agegroups", agegroups);
        theta = std::vector<double>(agegroups,double(0));
        vals_r__ = context__.vals_r("theta");
        pos__ = 0;
        size_t theta_limit_0__ = agegroups;
        for (size_t i_0__ = 0; i_0__ < theta_limit_0__; ++i_0__) {
            theta[i_0__] = vals_r__[pos__++];
        }
        context__.validate_dims("data initialization", "participation", "double", context__.to_vec(agegroups));
        validate_non_negative_index("participation", "agegroups", agegroups);
        participation = std::vector<double>(agegroups,double(0));
        vals_r__ = context__.vals_r("participation");
        pos__ = 0;
        size_t participation_limit_0__ = agegroups;
        for (size_t i_0__ = 0; i_0__ < participation_limit_0__; ++i_0__) {
            participation[i_0__] = vals_r__[pos__++];
        }
        context__.validate_dims("data initialization", "vol", "double", context__.to_vec(agegroups));
        validate_non_negative_index("vol", "agegroups", agegroups);
        vol = std::vector<double>(agegroups,double(0));
        vals_r__ = context__.vals_r("vol");
        pos__ = 0;
        size_t vol_limit_0__ = agegroups;
        for (size_t i_0__ = 0; i_0__ < vol_limit_0__; ++i_0__) {
            vol[i_0__] = vals_r__[pos__++];
        }

        // validate data
        check_greater_or_equal(function__,"ts",ts,1);
        for (int k0__ = 0; k0__ < ts; ++k0__) {
            check_greater_or_equal(function__,"tspan[k0__]",tspan[k0__],0);
        }
        check_greater_or_equal(function__,"agegroups",agegroups,0);
        check_greater_or_equal(function__,"thetaindicator",thetaindicator,0);
        check_less_or_equal(function__,"thetaindicator",thetaindicator,1);
        check_greater_or_equal(function__,"rindicator",rindicator,0);
        check_less_or_equal(function__,"rindicator",rindicator,1);
        for (int k0__ = 0; k0__ < agegroups; ++k0__) {
            check_greater_or_equal(function__,"cases[k0__]",cases[k0__],0);
        }
        for (int k0__ = 0; k0__ < 2; ++k0__) {
            check_greater_or_equal(function__,"casesdhaka2[k0__]",casesdhaka2[k0__],0);
        }
        check_greater_or_equal(function__,"dhaka",dhaka,0);
        check_less_or_equal(function__,"dhaka",dhaka,1);
        for (int k0__ = 0; k0__ < (agegroups * 8); ++k0__) {
            check_greater_or_equal(function__,"y0[k0__]",y0[k0__],0);
        }
        for (int k0__ = 0; k0__ < agegroups; ++k0__) {
            check_greater_or_equal(function__,"mu[k0__]",mu[k0__],0);
        }
        for (int k0__ = 0; k0__ < agegroups; ++k0__) {
            check_greater_or_equal(function__,"u[k0__]",u[k0__],0);
        }
        for (int k0__ = 0; k0__ < agegroups; ++k0__) {
            check_greater_or_equal(function__,"theta[k0__]",theta[k0__],0);
            check_less_or_equal(function__,"theta[k0__]",theta[k0__],1);
        }
        for (int k0__ = 0; k0__ < agegroups; ++k0__) {
            check_greater_or_equal(function__,"participation[k0__]",participation[k0__],0);
            check_less_or_equal(function__,"participation[k0__]",participation[k0__],1);
        }
        for (int k0__ = 0; k0__ < agegroups; ++k0__) {
            check_greater_or_equal(function__,"vol[k0__]",vol[k0__],0);
        }
        t0 = double(0);
        validate_non_negative_index("x_r", "(agegroups * 8)", (agegroups * 8));
        x_r = std::vector<double>((agegroups * 8),double(0));
        validate_non_negative_index("x_i", "3", 3);
        x_i = std::vector<int>(3,int(0));

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning


        // initialize transformed variables to avoid seg fault on val access
        stan::math::fill(t0,DUMMY_VAR__);
        stan::math::fill(x_r,DUMMY_VAR__);
        stan::math::fill(x_i,DUMMY_VAR__);

        try {
            current_statement_begin__ = 104;
            stan::math::assign(get_base1_lhs(x_i,1,"x_i",1), agegroups);
            current_statement_begin__ = 105;
            stan::math::assign(get_base1_lhs(x_i,2,"x_i",1), thetaindicator);
            current_statement_begin__ = 106;
            stan::math::assign(get_base1_lhs(x_i,3,"x_i",1), rindicator);
            current_statement_begin__ = 108;
            stan::math::assign(t0, 0);
            current_statement_begin__ = 109;
            stan::math::assign(x_r, make_x_r(agegroups,population,mub,alpha,omega,delta,mu,theta,u, pstream__));
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed data

        // set parameter ranges
        num_params_r__ = 0U;
        param_ranges_i__.clear();
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
        ++num_params_r__;
    }

    ~SIR_typhi_notheta_model() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("beta")))
            throw std::runtime_error("variable beta missing");
        vals_r__ = context__.vals_r("beta");
        pos__ = 0U;
        context__.validate_dims("initialization", "beta", "double", context__.to_vec());
        double beta(0);
        beta = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0.20000000000000001,5,beta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta: ") + e.what());
        }

        if (!(context__.contains_r("logm1")))
            throw std::runtime_error("variable logm1 missing");
        vals_r__ = context__.vals_r("logm1");
        pos__ = 0U;
        context__.validate_dims("initialization", "logm1", "double", context__.to_vec());
        double logm1(0);
        logm1 = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,logm1);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable logm1: ") + e.what());
        }

        if (!(context__.contains_r("logm2")))
            throw std::runtime_error("variable logm2 missing");
        vals_r__ = context__.vals_r("logm2");
        pos__ = 0U;
        context__.validate_dims("initialization", "logm2", "double", context__.to_vec());
        double logm2(0);
        logm2 = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,logm2);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable logm2: ") + e.what());
        }

        if (!(context__.contains_r("sensrate")))
            throw std::runtime_error("variable sensrate missing");
        vals_r__ = context__.vals_r("sensrate");
        pos__ = 0U;
        context__.validate_dims("initialization", "sensrate", "double", context__.to_vec());
        double sensrate(0);
        sensrate = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,sensrate);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sensrate: ") + e.what());
        }

        if (!(context__.contains_r("logprop")))
            throw std::runtime_error("variable logprop missing");
        vals_r__ = context__.vals_r("logprop");
        pos__ = 0U;
        context__.validate_dims("initialization", "logprop", "double", context__.to_vec());
        double logprop(0);
        logprop = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,logprop);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable logprop: ") + e.what());
        }

        if (!(context__.contains_r("r")))
            throw std::runtime_error("variable r missing");
        vals_r__ = context__.vals_r("r");
        pos__ = 0U;
        context__.validate_dims("initialization", "r", "double", context__.to_vec());
        double r(0);
        r = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,r);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable r: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        // model parameters
        stan::io::reader<T__> in__(params_r__,params_i__);

        T__ beta;
        (void) beta;   // dummy to suppress unused var warning
        if (jacobian__)
            beta = in__.scalar_lub_constrain(0.20000000000000001,5,lp__);
        else
            beta = in__.scalar_lub_constrain(0.20000000000000001,5);

        T__ logm1;
        (void) logm1;   // dummy to suppress unused var warning
        if (jacobian__)
            logm1 = in__.scalar_lb_constrain(0,lp__);
        else
            logm1 = in__.scalar_lb_constrain(0);

        T__ logm2;
        (void) logm2;   // dummy to suppress unused var warning
        if (jacobian__)
            logm2 = in__.scalar_lb_constrain(0,lp__);
        else
            logm2 = in__.scalar_lb_constrain(0);

        T__ sensrate;
        (void) sensrate;   // dummy to suppress unused var warning
        if (jacobian__)
            sensrate = in__.scalar_lb_constrain(0,lp__);
        else
            sensrate = in__.scalar_lb_constrain(0);

        T__ logprop;
        (void) logprop;   // dummy to suppress unused var warning
        if (jacobian__)
            logprop = in__.scalar_lb_constrain(0,lp__);
        else
            logprop = in__.scalar_lb_constrain(0);

        T__ r;
        (void) r;   // dummy to suppress unused var warning
        if (jacobian__)
            r = in__.scalar_lub_constrain(0,1,lp__);
        else
            r = in__.scalar_lub_constrain(0,1);


        // transformed parameters
        vector<T__> params((agegroups + 1));
        vector<T__> blood(agegroups);
        T__ prop;
        (void) prop;  // dummy to suppress unused var warning

        // initialize transformed variables to avoid seg fault on val access
        stan::math::fill(params,DUMMY_VAR__);
        stan::math::fill(blood,DUMMY_VAR__);
        stan::math::fill(prop,DUMMY_VAR__);

        try {
            current_statement_begin__ = 126;
            stan::math::assign(params, make_params(beta,logm1,logm2,r,agegroups, pstream__));
            current_statement_begin__ = 128;
            for (int i = 1; i <= agegroups; ++i) {
                current_statement_begin__ = 129;
                stan::math::assign(get_base1_lhs(blood,i,"blood",1), (1 - exp((-(sensrate) * get_base1(vol,i,"vol",1)))));
            }
            current_statement_begin__ = 131;
            stan::math::assign(prop, (1 - exp(-(logprop))));
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        for (int i0__ = 0; i0__ < (agegroups + 1); ++i0__) {
            if (stan::math::is_uninitialized(params[i0__])) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: params" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        for (int i0__ = 0; i0__ < agegroups; ++i0__) {
            if (stan::math::is_uninitialized(blood[i0__])) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: blood" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }
        if (stan::math::is_uninitialized(prop)) {
            std::stringstream msg__;
            msg__ << "Undefined transformed parameter: prop";
            throw std::runtime_error(msg__.str());
        }

        const char* function__ = "validate transformed params";
        (void) function__; // dummy to suppress unused var warning

        // model body
        try {
            {
                vector<vector<T__> > yhat(ts, (vector<T__>((agegroups * 8))));
                stan::math::initialize(yhat, DUMMY_VAR__);
                current_statement_begin__ = 140;
                lp_accum__.add(uniform_log<propto__>(beta, 0.20000000000000001, 5));
                current_statement_begin__ = 141;
                lp_accum__.add(exponential_log<propto__>(logm1, 1));
                current_statement_begin__ = 142;
                lp_accum__.add(exponential_log<propto__>(logm2, 1));
                current_statement_begin__ = 143;
                lp_accum__.add(beta_log<propto__>(r, 1.9173, 57.415999999999997));
                current_statement_begin__ = 146;
                stan::math::assign(yhat, integrate_ode(sir_functor__(), stan::model::rvalue(y0, stan::model::cons_list(stan::model::index_min_max(1, (agegroups * 8)), stan::model::nil_index_list()), "y0"), t0, tspan, params, x_r, x_i, pstream__));
                current_statement_begin__ = 150;
                lp_accum__.add(exponential_log<propto__>(logprop, 1));
                current_statement_begin__ = 151;
                lp_accum__.add(gamma_log<propto__>(sensrate, 44.808599999999998, (1 / 0.0030999999999999999)));
                current_statement_begin__ = 154;
                for (int i = 1; i <= agegroups; ++i) {
                    current_statement_begin__ = 155;
                    lp_accum__.add(poisson_log<propto__>(get_base1(cases,i,"cases",1), ((((get_base1(get_base1(yhat,ts,"yhat",1),(i + (agegroups * 6)),"yhat",2) - get_base1(get_base1(yhat,(ts - 52),"yhat",1),(i + (agegroups * 6)),"yhat",2)) * get_base1(participation,i,"participation",1)) * get_base1(blood,i,"blood",1)) * prop)));
                }
                current_statement_begin__ = 156;
                if (as_bool(logical_eq(dhaka,1))) {
                    current_statement_begin__ = 157;
                    lp_accum__.add(poisson_log<propto__>(get_base1(casesdhaka2,1,"casesdhaka2",1), ((((sum(stan::model::rvalue(yhat, stan::model::cons_list(stan::model::index_uni(ts), stan::model::cons_list(stan::model::index_min_max((1 + (agegroups * 6)), (2 + (agegroups * 6))), stan::model::nil_index_list())), "yhat")) - sum(stan::model::rvalue(yhat, stan::model::cons_list(stan::model::index_uni((ts - 52)), stan::model::cons_list(stan::model::index_min_max((1 + (agegroups * 6)), (2 + (agegroups * 6))), stan::model::nil_index_list())), "yhat"))) * get_base1(participation,2,"participation",1)) * get_base1(blood,2,"blood",1)) * prop)));
                    current_statement_begin__ = 158;
                    lp_accum__.add(poisson_log<propto__>(get_base1(casesdhaka2,2,"casesdhaka2",1), ((((sum(stan::model::rvalue(yhat, stan::model::cons_list(stan::model::index_uni(ts), stan::model::cons_list(stan::model::index_min_max((3 + (agegroups * 6)), (4 + (agegroups * 6))), stan::model::nil_index_list())), "yhat")) - sum(stan::model::rvalue(yhat, stan::model::cons_list(stan::model::index_uni((ts - 52)), stan::model::cons_list(stan::model::index_min_max((3 + (agegroups * 6)), (4 + (agegroups * 6))), stan::model::nil_index_list())), "yhat"))) * get_base1(participation,4,"participation",1)) * get_base1(blood,4,"blood",1)) * prop)));
                }
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("beta");
        names__.push_back("logm1");
        names__.push_back("logm2");
        names__.push_back("sensrate");
        names__.push_back("logprop");
        names__.push_back("r");
        names__.push_back("params");
        names__.push_back("blood");
        names__.push_back("prop");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((agegroups + 1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(agegroups);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "SIR_typhi_notheta_model_namespace::write_array";
        (void) function__; // dummy call to supress warning
        // read-transform, write parameters
        double beta = in__.scalar_lub_constrain(0.20000000000000001,5);
        double logm1 = in__.scalar_lb_constrain(0);
        double logm2 = in__.scalar_lb_constrain(0);
        double sensrate = in__.scalar_lb_constrain(0);
        double logprop = in__.scalar_lb_constrain(0);
        double r = in__.scalar_lub_constrain(0,1);
        vars__.push_back(beta);
        vars__.push_back(logm1);
        vars__.push_back(logm2);
        vars__.push_back(sensrate);
        vars__.push_back(logprop);
        vars__.push_back(r);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__; // dummy call to supress warning
        stan::math::accumulator<double> lp_accum__;

        vector<double> params((agegroups + 1), 0.0);
        vector<double> blood(agegroups, 0.0);
        double prop(0.0);
        (void) prop;  // dummy to suppress unused var warning

        try {
            current_statement_begin__ = 126;
            stan::math::assign(params, make_params(beta,logm1,logm2,r,agegroups, pstream__));
            current_statement_begin__ = 128;
            for (int i = 1; i <= agegroups; ++i) {
                current_statement_begin__ = 129;
                stan::math::assign(get_base1_lhs(blood,i,"blood",1), (1 - exp((-(sensrate) * get_base1(vol,i,"vol",1)))));
            }
            current_statement_begin__ = 131;
            stan::math::assign(prop, (1 - exp(-(logprop))));
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters

        // write transformed parameters
        for (int k_0__ = 0; k_0__ < (agegroups + 1); ++k_0__) {
            vars__.push_back(params[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < agegroups; ++k_0__) {
            vars__.push_back(blood[k_0__]);
        }
        vars__.push_back(prop);

        if (!include_gqs__) return;
        // declare and define generated quantities

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning


        // initialize transformed variables to avoid seg fault on val access

        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate generated quantities

        // write generated quantities
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "SIR_typhi_notheta_model";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "logm1";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "logm2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sensrate";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "logprop";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "r";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= (agegroups + 1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "params" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= agegroups; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "blood" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "prop";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "logm1";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "logm2";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sensrate";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "logprop";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "r";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= (agegroups + 1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "params" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= agegroups; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "blood" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "prop";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
    }

}; // model

} // namespace

typedef SIR_typhi_notheta_model_namespace::SIR_typhi_notheta_model stan_model;


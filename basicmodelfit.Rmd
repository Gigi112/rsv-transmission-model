---
title: "CT_rsv_wkly"
author: "ZHE ZHENG"
date: "8/13/2020"
output: html_document
---

```{r}
library(haven)
rsv <- read.csv("~/Box/aim2/data/ZIPPED files/weekly5_atp_full_new.csv")
rsv <- rsv$rsv2_I
rsv <- as.data.frame(rsv)
rsv$time <- seq(round(52.18*51),round(52.18*51)+783-1,by=1)
```

```{r}
require(deSolve)
require(ggplot2)

# INPUT
initial_state_values <- St0

times <- seq(1, tmax, by = 1) # gives a sequence from start to end

# MSIS MODEL FUNCTION
my_model <- function(times,x,pars){
  
  b=ptrans/dur
  beta=(b/100)/(sum(N0state)^(1-q))*c2
  
  nage <- al 
  M    = x[1:nage]
  S0    = x[(nage+1):(2*nage)]
  I1    = x[(2*nage+1):(3*nage)]
  S1    = x[(3*nage+1):(4*nage)]
  I2    = x[(4*nage+1):(5*nage)]
  S2    = x[(5*nage+1):(6*nage)]
  I3    = x[(6*nage+1):(7*nage)]
  S3    = x[(7*nage+1):(8*nage)]
  I4    = x[(8*nage+1):(9*nage)]
  
  dx <- rep(0,9*al)
  
  lambda=(1+b1*cos(2*pi*(times-phi*52.18)/52.18))%*%t(x[(2*al+1):(3*al)]+rho1*x[(4*al+1):(5*al)]+rho2*x[(6*al+1):(7*al)]+rho2*x[(8*al+1):(9*al)])%*%beta/sum(x)
  
	for (a in 1:nage) {
	  
	  dx[a] <- log(B[times,a]+1)/52*sum(x)-(omega+(u[a]+um))*M[a] #dM/dt
		dx[a+nage] <- omega*M[a]-sum(lambda[,a])*S0[a]-(u[a]+um)*S0[a] #dS0/dt
		dx[a+2*nage] <- sum(lambda[,a])*S0[a]- gamma1*I1[a]-(u[a]+um)*I1[a] #dI1/dt
		dx[a+3*nage] <- gamma1*I1[a]-sigma1*sum(lambda[,a])*S1[a]-(u[a]+um)*S1[a] #dS1/dt
		dx[a+4*nage] <- sigma1*sum(lambda[,a])*S1[a]- gamma1*I2[a]-(u[a]+um)*I2[a] #dI2/dt
		dx[a+5*nage] <- gamma1*I2[a]- sigma2*sum(lambda[,a])*S2[a]-(u[a]+um)*S2[a] #dS2/dt
		dx[a+6*nage] <- sigma2*sum(lambda[,a])*S2[a]-gamma2*I3[a]-(u[a]+um)*I3[a] #dI3/dt
		dx[a+7*nage] <- gamma2*I3[a]-sigma3*sum(lambda[,a])*S3[a]+gamma3*I4[a]-(u[a]+um)*S3[a] #dS3/dt
		dx[a+8*nage] <- sigma3*sum(lambda[,a])*S3[a]-gamma3*I4[a]-(u[a]+um)*I4[a] #dI4/dt
		
		if (a >1 ){
		dx[a] <- dx[a]+ u[a-1]*M[a-1]
		dx[a+nage] <- dx[a+nage] + u[a-1]*S0[a-1]
		dx[a+2*nage] <- dx[a+2*nage] + u[a-1]*I1[a-1]
		dx[a+3*nage] <-dx[a+3*nage]+u[a-1]*S1[a-1]
		dx[a+4*nage] <- dx[a+4*nage]+u[a-1]*I2[a-1]
		dx[a+5*nage] <- dx[a+5*nage]+u[a-1]*S2[a-1]
		dx[a+6*nage] <- dx[a+6*nage]+u[a-1]*I3[a-1]
		dx[a+7*nage] <- dx[a+7*nage]+u[a-1]*S3[a-1]
		dx[a+8*nage] <- dx[a+8*nage]+u[a-1]*I4[a-1]
		}
	  
	}
	
	return(list(dx))}

################## Setting Parameters ##################

rho1 = ri2
rho2 = ri3
gamma1=d1
gamma2=d2
gamma3=d3
omega=wm
u=u
um=um
B=B
sigma1=rr1
sigma2=rr2
sigma3=rr3
dur=1.43
#lambda1=rsvmatdata$lambda

parmset<-list(B=B,omega=omega,u=u,um=um,rho1=rho1,rho2=rho2,dur=dur, gamma1=gamma1,sigma1=sigma1,gamma2=gamma2,sigma2=sigma2,gamma3=gamma3,sigma3=sigma3)

parameters <- c(ptrans = ptrans,b1 = b1,phi = phi)

loglik_function <- function(parameters,dat) {   # takes as inputs the parameter values and dataset
  ptrans <- parameters[1]
  b1 <- parameters[2]
  phi <- parameters[3]
  ptrans <<- ptrans
  b1 <<- b1
  phi <<- phi
   # Simulate the model with initial conditions and timesteps defined above, and parameter values from function call
   output <- as.data.frame(ode(y = initial_state_values, 
                               times = times, 
                               func = my_model,
                               parms = c(parmset,ptrans,b1,phi)))
   
   output <- tail(output,1225)
   St <- output[,-1]

   St <- as.matrix(St)
   
   b=ptrans/dur
   beta=(b/100)/(sum(N0state)^(1-q))*c2
 
   lambda1=matrix(0,nrow=tmax-t0,ncol=al)#Force of infection
    for (t in 1:1225)
    {lambda1[t,] <- as.vector((1+b1*cos(2*pi*(t-phi*52.18)/52.18))*((St[t,(2*al+1):(3*al)]+rho1*St[t,(4*al+1):(5*al)]+rho2*St[t,(6*al+1):(7*al)]+rho2*St[t,(8*al+1):(9*al)])%*%beta)/sum(St[t,]))}

   
   H1=matrix(0,nrow=tmax-t0,ncol=al)#Number of hospitalizations by age
   for (i in 1:al){
     H1[,i]=hosp1[i]*St[,(al+i)]*lambda1[,i]+hosp2[i]*rr1*St[,(3*al+i)]*lambda1[,i]+hosp3[i]*rr2*St[,(5*al+i)]*lambda1[,i]+hosp4[i]*rr3*St[,(7*al+i)]*lambda1[,i]
   }
   H <- rowSums(H1)
   
   LL <- sum(dpois(x = dat$rsv, lambda =H[output$time %in% rsv$time], log = TRUE)) 
   return(LL)
   }

minLL <- optim(par = c(7.9,.38,0.5),           # starting values for beta and gamma - you should get the same result no matter                              # which values you choose here
      fn = loglik_function,        # the distance function to optimise
      dat = rsv,         # the dataset to fit to ("dat" argument is passed to the function specified in fn)
      control = list(fnscale=-1),
      lower=c(0, 0, -Inf), upper=rep(Inf, 3),
      method="L-BFGS-B")  # tells optim() to look for the maximum number 

```

